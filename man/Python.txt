Функция int() позволяет выполнять конвертацию в тип int (из строки в число) только из целого числа???
In [18]: a = '11'
In [19]: int(a)
Out[19]: 11

Если указать, что строку a надо воспринимать как двоичное число, то результат будет таким:
In [20]: int(a, 2)
Out[20]: 3
__________________________________числа_______________________________________

Функция bin позволяет получить двоичное представление числа (обратите внимание, что результат - строка):
In [23]: bin(8)
Out[23]: '0b1000'

In [24]: bin(255)
Out[24]: '0b11111111'
__________________________________числа_______________________________________

Аналогично, функция hex() позволяет получить шестнадцатеричное значение:

In [25]: hex(10)
Out[25]: '0xa'
__________________________________числа_______________________________________

__________________________________строки_______________________________________
Функция len позволяет получить количество символов в строке:

In [1]: line = 'interface Gi0/1'

In [2]: len(line)
Out[2]: 15
__________________________________строки_______________________________________

Методы upper(), lower(), swapcase(), capitalize() выполняют преобразование регистра строки:

In [25]: string1 = 'FastEthernet'

Все большими буквами
In [26]: string1.upper()
Out[26]: 'FASTETHERNET'

Все маленькими буквами
In [27]: string1.lower()
Out[27]: 'fastethernet'

Смена большие на маленькие
In [28]: string1.swapcase()
Out[28]: 'fASTeTHERNET'

Первую букву делает большой
In [29]: string2 = 'tunnel 0'
In [30]: string2.capitalize()
Out[30]: 'Tunnel 0'
__________________________________строки_______________________________________

Метод count() используется для подсчета того, сколько раз символ или подстрока встречаются в строке:

In [33]: string1 = 'Hello, hello, hello, hello'

In [34]: string1.count('hello')
Out[34]: 3

In [35]: string1.count('ello')
Out[35]: 4
__________________________________строки_______________________________________

Методу find() можно передать подстроку или символ, и он покажет, 
на какой позиции находится первый символ подстроки (для первого совпадения):

In [37]: string1 = 'interface FastEthernet0/1'

In [38]: string1.find('Fast')
Out[38]: 10

In [39]: string1[string1.find('Fast')::]
Out[39]: 'FastEthernet0/1'
__________________________________строки_______________________________________

Проверка на то, начинается или заканчивается ли строка 
на определенные символы (методы startswith(), endswith()):

In [40]: string1 = 'FastEthernet0/1'

In [41]: string1.startswith('Fast')
Out[41]: True

In [42]: string1.startswith('fast')
Out[42]: False

In [43]: string1.endswith('0/1')
Out[43]: True

In [44]: string1.endswith('0/2')
Out[44]: False

__________________________________строки_______________________________________

Замена последовательности символов в строке на другую последовательность (метод replace()):

In [45]: string1 = 'FastEthernet0/1'

In [46]: string1.replace('Fast', 'Gigabit')
Out[46]: 'GigabitEthernet0/1'

__________________________________строки_______________________________________

Для того, чтобы избавиться от спецсимволов, очень удобно использовать метод strip():

In [47]: string1 = '\n\tinterface FastEthernet0/1\n'

In [48]: print(string1)

    interface FastEthernet0/1


In [49]: string1
Out[49]: '\n\tinterface FastEthernet0/1\n'

In [50]: string1.strip()
Out[50]: 'interface FastEthernet0/1'
 
 
In [51]: ad_metric = '[110/1045]'

In [52]: ad_metric.strip('[]')
Out[52]: '110/1045'

Метод strip() убирает спецсимволы и в начале, и в конце строки. 
Если необходимо убрать символы только слева или только справа, 
можно использовать, соответственно, методы lstrip() и rstrip().

__________________________________строки_______________________________________

Из строки делает список
Метод split() разбивает строку на части,
используя как разделитель какой-то символ (или символы) и возвращает список строк:

In [53]: string1 = 'switchport trunk allowed vlan 10,20,30,100-200'

In [54]: commands = string1.split()

In [55]: print(commands)
['switchport', 'trunk', 'allowed', 'vlan', '10,20,30,100-200']

__________________________________строки_______________________________________

Форматирование строк с методом format
Вставляет в скабки значение

In [1]: "interface FastEthernet0/{}".format('1')
Out[1]: 'interface FastEthernet0/1'

In [3]: vlan, mac, intf = ['100', 'aabb.cc80.7000', 'Gi0/1']

In [4]: print("{:>15} {:>15} {:>15}".format(vlan, mac, intf))
            100  aabb.cc80.7000           Gi0/1

Выравнивание по левой стороне:

In [5]: print("{:15} {:15} {:15}".format(vlan, mac, intf))
100             aabb.cc80.7000  Gi0/1

______________________________

Указав индексы значений, которые передаются методу format, можно избавиться от дублирования:

In [21]: ip_template = '''
    ...: IP address:
    ...: {0:<8} {1:<8} {2:<8} {3:<8}
    ...: {0:08b} {1:08b} {2:08b} {3:08b}
    ...: '''

In [22]: print(ip_template.format(192, 100, 1, 1))

IP address:
192      100      1        1
11000000 01100100 00000001 00000001

__________________________________строки_______________________________________

In [1]: ip = '10.1.1.1'

In [2]: mask = 24

In [3]: f"IP: {ip}, mask: {mask}"
Out[3]: 'IP: 10.1.1.1, mask: 24'

Аналогичный результат с format можно получить так:
``"IP: {ip}, mask: {mask}".format(ip=ip, mask=mask)``.

Очень важное отличие f-строк от format: f-строки — это выражение, которое выполняется, а не просто строка. 
То есть, в случае с ipython, как только мы написали выражение и нажали Enter, 
оно выполнилось и вместо выражений {ip} и {mask} подставились значения переменных.

Поэтому, например, нельзя сначала написать шаблон, а затем определить переменные, которые используются в шаблоне:

__________________________________строки_______________________________________

Перевернуть список наоборот можно и с помощью метода reverse():

In [10]: vlans = ['10', '15', '20', '30', '100-200']

In [11]: vlans.reverse()

In [12]: vlans
Out[12]: ['100-200', '30', '20', '15', '10']

__________________________________списки_______________________________________

Функция len возвращает количество элементов в списке:

In [1]: items = [1, 2, 3]

In [2]: len(items)
Out[2]: 3

__________________________________списки_______________________________________

А функция sorted сортирует элементы списка по возрастанию и возвращает новый список с отсортированными элементами:

In [1]: names = ['John', 'Michael', 'Antony']

In [2]: sorted(names)
Out[2]: ['Antony', 'John', 'Michael']

__________________________________списки_______________________________________

Метод join() собирает список в строку с разделителем, который указан перед join:

In [16]: vlans = ['10', '20', '30']

In [17]: ','.join(vlans)
Out[17]: '10,20,30'

__________________________________списки_______________________________________

Метод append() добавляет в конец списка указанный элемент:

In [18]: vlans = ['10', '20', '30', '100-200']

In [19]: vlans.append('300')

In [20]: vlans
Out[20]: ['10', '20', '30', '100-200', '300']

Метод append меняет список на месте и ничего не возвращает.

__________________________________списки_______________________________________

Если нужно объединить два списка, то можно использовать два способа: метод extend() и операцию сложения.
У этих способов есть важное отличие - extend меняет список, к которому применен метод,
а суммирование возвращает новый список, который состоит из двух.

In [21]: vlans = ['10', '20', '30', '100-200']

In [22]: vlans2 = ['300', '400', '500']

In [23]: vlans.extend(vlans2)

In [24]: vlans
Out[24]: ['10', '20', '30', '100-200', '300', '400', '500']

Суммирование списков:

In [27]: vlans = ['10', '20', '30', '100-200']

In [28]: vlans2 = ['300', '400', '500']

In [29]: vlans + vlans2
Out[29]: ['10', '20', '30', '100-200', '300', '400', '500']

__________________________________списки_______________________________________
Удалить из списка
Метод pop() удаляет элемент, который соответствует указанному номеру.
Но, что важно, при этом метод возвращает этот элемент:

In [28]: vlans = ['10', '20', '30', '100-200']

In [29]: vlans.pop(-1)
Out[29]: '100-200'

In [30]: vlans
Out[30]: ['10', '20', '30']
_____

Метод remove() удаляет указанный элемент.

remove() не возвращает удаленный элемент:

In [31]: vlans = ['10', '20', '30', '100-200']

In [32]: vlans.remove('20')

In [33]: vlans
Out[33]: ['10', '30', '100-200']

В методе remove надо указывать сам элемент, который надо удалить, а не его номер в списке. 
Если указать номер элемента, возникнет ошибка:

__________________________________списки_______________________________________

Метод index() используется для того, чтобы проверить, 
под каким номером в списке хранится элемент:

In [35]: vlans = ['10', '20', '30', '100-200']

In [36]: vlans.index('30')
Out[36]: 2

__________________________________списки_______________________________________

Метод insert() позволяет вставить элемент на определенное место в списке:

In [37]: vlans = ['10', '20', '30', '100-200']

In [38]: vlans.insert(1, '15')

In [39]: vlans
Out[39]: ['10', '15', '20', '30', '100-200']

__________________________________списки_______________________________________

Метод sort сортирует список на месте:

In [40]: vlans = [1, 50, 10, 15]

In [41]: vlans.sort()

In [42]: vlans
Out[42]: [1, 10, 15, 50]

__________________________________словари_______________________________________

Метод clear() позволяет очистить словарь:

In [1]: london = {'name': 'London1', 'location': 'London Str', 'vendor': 'Cisco', 'model': '4451', 'ios': '15.4'}

In [2]: london.clear()

In [3]: london
Out[3]: {}

---------
copy()

Метод copy() позволяет создать полную копию словаря.

Если указать, что один словарь равен другому:

london = {'name': 'London1', 'location': 'London Str', 'vendor': 'Cisco'}

In [11]: london2 = london.copy()

In [12]: id(london)
Out[12]: 25524512

In [13]: id(london2)
Out[13]: 25563296

In [14]: london['vendor'] = 'Juniper'

In [15]: london2['vendor']
Out[15]: 'Cisco'

__________________________________словари_______________________________________

Метод get() запрашивает ключ, и если его нет, вместо ошибки возвращает None.

In [18]: london = {'name': 'London1', 'location': 'London Str', 'vendor': 'Cisco'}

In [19]: print(london.get('ios'))
None

Метод get() позволяет также указывать другое значение вместо None:

In [20]: print(london.get('ios', 'Ooops'))
Ooops

__________________________________словари_______________________________________

Метод setdefault() ищет ключ, и если его нет, вместо ошибки создает ключ со значением None.

In [21]: london = {'name': 'London1', 'location': 'London Str', 'vendor': 'Cisco'}

In [22]: ios = london.setdefault('ios')

In [23]: print(ios)
None

In [24]: london
Out[24]: {'name': 'London1', 'location': 'London Str', 'vendor': 'Cisco', 'ios': None}

Если ключ есть, setdefault возвращает значение, которое ему соответствует:

In [25]: london.setdefault('name')
Out[25]: 'London1'

__________________________________словари_______________________________________

Методы keys(), values(), items():

In [24]: london = {'name': 'London1', 'location': 'London Str', 'vendor': 'Cisco'}

In [25]: london.keys()
Out[25]: dict_keys(['name', 'location', 'vendor'])

In [26]: london.values()
Out[26]: dict_values(['London1', 'London Str', 'Cisco'])

In [27]: london.items()
Out[27]: dict_items([('name', 'London1'), ('location', 'London Str'), ('vendor', 'Cisco')])

Все три метода возвращают специальные объекты view, 
которые отображают ключи, значения и пары ключ-значение словаря соответственно.

__________________________________словари_______________________________________


del

Удалить ключ и значение:

In [35]: london = {'name': 'London1', 'location': 'London Str', 'vendor': 'Cisco'}

In [36]: del london['name']

In [37]: london
Out[37]: {'location': 'London Str', 'vendor': 'Cisco'}

__________________________________словари_______________________________________

update

Метод update позволяет добавлять в словарь содержимое другого словаря:

In [38]: r1 = {'name': 'London1', 'location': 'London Str'}

In [39]: r1.update({'vendor': 'Cisco', 'ios':'15.2'})

In [40]: r1
Out[40]: {'name': 'London1', 'location': 'London Str', 'vendor': 'Cisco', 'ios': '15.2'
--------------------
Аналогичным образом можно обновить значения:

In [41]: r1.update({'name': 'london-r1', 'ios':'15.4'})

In [42]: r1
Out[42]:
{'name': 'london-r1',
 'location': 'London Str',
 'vendor': 'Cisco',
 'ios': '15.4'}
__________________________________словари_______________________________________

В ситуации, когда надо создать словарь с известными ключами, но пока что пустыми значениями 
(или одинаковыми значениями), очень удобен метод fromkeys():

In [5]: d_keys = ['hostname', 'location', 'vendor', 'model', 'ios', 'ip']

In [6]: r1 = dict.fromkeys(d_keys)

In [7]: r1
Out[7]:
{'hostname': None,
 'location': None,
 'vendor': None,
 'model': None,
 'ios': None,
 'ip': None}
 --------------------
 
 По умолчанию метод fromkeys подставляет значение None. Но можно указывать и свой вариант значения:

In [8]: router_models = ['ISR2811', 'ISR2911', 'ISR2921', 'ASR9002']

In [9]: models_count = dict.fromkeys(router_models, 0)

In [10]: models_count
Out[10]: {'ISR2811': 0, 'ISR2911': 0, 'ISR2921': 0, 'ASR9002': 0}

__________________________________словари_______________________________________

__________________________________кортеж_______________________________________

Кортеж из списка:

In [4]: list_keys = ['hostname', 'location', 'vendor', 'model', 'ios', 'ip']

In [5]: tuple_keys = tuple(list_keys)

In [6]: tuple_keys
Out[6]: ('hostname', 'location', 'vendor', 'model', 'ios', 'ip')

__________________________________кортеж_______________________________________

Функция sorted сортирует элементы кортежа по возрастанию и 
возвращает новый список с отсортированными элементами:

In [2]: tuple_keys = ('hostname', 'location', 'vendor', 'model', 'ios', 'ip')

In [3]: sorted(tuple_keys)
Out[3]: ['hostname', 'ios', 'ip', 'location', 'model', 'vendor']

__________________________________кортеж_______________________________________

__________________________________множества_______________________________________

Множество (Set)

Множество - это изменяемый неупорядоченный тип данных.
В множестве всегда содержатся только уникальные элементы.

Множество в Python - это последовательность элементов, 
которые разделены между собой запятой и заключены в фигурные скобки.

С помощью множества можно легко убрать повторяющиеся элементы:

In [1]: vlans = [10, 20, 30, 40, 100, 10]

In [2]: set(vlans)
Out[2]: {10, 20, 30, 40, 100}

In [3]: set1 = set(vlans)

In [4]: print(set1)
{40, 100, 10, 20, 30}
__________________________________множества_______________________________________
Метод add() добавляет элемент во множество:

In [1]: set1 = {10,20,30,40}

In [2]: set1.add(50)

In [3]: set1
Out[3]: {10, 20, 30, 40, 50}

__________________________________множества_______________________________________

Метод discard() позволяет удалять элементы, не выдавая ошибку, если элемента в множестве нет:

In [3]: set1
Out[3]: {10, 20, 30, 40, 50}

In [4]: set1.discard(55)

In [5]: set1
Out[5]: {10, 20, 30, 40, 50}

In [6]: set1.discard(50)

In [7]: set1
Out[7]: {10, 20, 30, 40}
__________________________________множества_______________________________________
Метод clear() очищает множество:

In [8]: set1 = {10,20,30,40}

In [9]: set1.clear()

In [10]: set1
Out[10]: set()
__________________________________множества_______________________________________

Объединение множеств можно получить с помощью метода union() или оператора |:

In [1]: vlans1 = {10,20,30,50,100}
In [2]: vlans2 = {100,101,102,102,200}

In [3]: vlans1.union(vlans2)
Out[3]: {10, 20, 30, 50, 100, 101, 102, 200}

In [4]: vlans1 | vlans2
Out[4]: {10, 20, 30, 50, 100, 101, 102, 200}

__________________________________множества_______________________________________
Пересечение множеств можно получить с помощью метода intersection() или оператора &:

In [5]: vlans1 = {10,20,30,50,100}
In [6]: vlans2 = {100,101,102,102,200}

In [7]: vlans1.intersection(vlans2)
Out[7]: {100}

In [8]: vlans1 & vlans2
Out[8]: {100}
__________________________________множества_______________________________________
Множество из строки:

In [5]: set('long long long long string')
Out[5]: {' ', 'g', 'i', 'l', 'n', 'o', 'r', 's', 't'}

Множество из списка:

In [6]: set([10,20,30,10,10,30])
Out[6]: {10, 20, 30}
__________________________________множества_______________________________________

__________________________________Преобразование типов_______________________________________

int() преобразует строку в int:

In [1]: int("10")
Out[1]: 10

С помощью функции int можно преобразовать и число в двоичной записи в десятичную
(двоичная запись должна быть в виде строки)

In [2]: int("11111111", 2)
Out[2]: 255

bin()

Преобразовать десятичное число в двоичный формат можно с помощью bin():

In [3]: bin(10)
Out[3]: '0b1010'

In [4]: bin(255)
Out[4]: '0b11111111'

hex()

Аналогичная функция есть и для преобразования в шестнадцатеричный формат:

In [5]: hex(10)
Out[5]: '0xa'

In [6]: hex(255)
Out[6]: '0xff'

list()

Функция list() преобразует аргумент в список:

In [7]: list("string")
Out[7]: ['s', 't', 'r', 'i', 'n', 'g']

In [8]: list({1,2,3})
Out[8]: [1, 2, 3]

In [9]: list((1,2,3,4))
Out[9]: [1, 2, 3, 4]

set()

Функция set() преобразует аргумент в множество:

In [10]: set([1,2,3,3,4,4,4,4])
Out[10]: {1, 2, 3, 4}

In [11]: set((1,2,3,3,4,4,4,4))
Out[11]: {1, 2, 3, 4}

In [12]: set("string string")
Out[12]: {' ', 'g', 'i', 'n', 'r', 's', 't'}

Эта функция очень полезна, когда нужно получить уникальные элементы в последовательности.
tuple()

Функция tuple() преобразует аргумент в кортеж:

In [13]: tuple([1,2,3,4])
Out[13]: (1, 2, 3, 4)

In [14]: tuple({1,2,3,4})
Out[14]: (1, 2, 3, 4)

In [15]: tuple("string")
Out[15]: ('s', 't', 'r', 'i', 'n', 'g')

Это может пригодиться в том случае, если нужно получить неизменяемый объект.
str()

Функция str() преобразует аргумент в строку:

In [16]: str(10)
Out[16]: '10'
__________________________________Преобразование типов_______________________________________


isdigit()

В Python такие методы есть. Например, чтобы проверить, 
состоит ли строка из одних цифр, можно использовать метод isdigit():

In [2]: "a".isdigit()
Out[2]: False

In [3]: "a10".isdigit()
Out[3]: False

In [4]: "10".isdigit()
Out[4]: True

isalpha()

Метод isalpha() позволяет проверить, состоит ли строка из одних букв:

In [7]: "a".isalpha()
Out[7]: True

In [8]: "a100".isalpha()
Out[8]: False

In [9]: "a--  ".isalpha()
Out[9]: False

In [10]: "a ".isalpha()
Out[10]: False

isalnum()

Метод isalnum() позволяет проверить, состоит ли строка из букв или цифр:

In [11]: "a".isalnum()
Out[1]: True

In [12]: "a10".isalnum()
Out[12]: True

type()

Иногда, в зависимости от результата, библиотека или функция может выводить разные типы объектов. 
Например, если объект один, возвращается строка, если несколько, то возвращается кортеж.

Нам же надо построить ход программы по-разному, в зависимости от того, была ли возвращена строка или кортеж.

В этом может помочь функция type():

In [13]: type("string")
Out[13]: str

In [14]: type("string") is str
Out[14]: True

Аналогично с кортежем (и другими типами данных):

In [15]: type((1,2,3))
Out[15]: tuple

In [16]: type((1,2,3)) is tuple
Out[16]: True

In [17]: type((1,2,3)) is list
Out[17]: False

__________________________________Преобразование типов_______________________________________



