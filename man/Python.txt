Функция int() позволяет выполнять конвертацию в тип int (из строки в число) только из целого числа???
In [18]: a = '11'
In [19]: int(a)
Out[19]: 11

Если указать, что строку a надо воспринимать как двоичное число, то результат будет таким:
In [20]: int(a, 2)
Out[20]: 3
__________________________________числа_______________________________________

Функция bin позволяет получить двоичное представление числа (обратите внимание, что результат - строка):
In [23]: bin(8)
Out[23]: '0b1000'

In [24]: bin(255)
Out[24]: '0b11111111'
__________________________________числа_______________________________________

Аналогично, функция hex() позволяет получить шестнадцатеричное значение:

In [25]: hex(10)
Out[25]: '0xa'
__________________________________числа_______________________________________

__________________________________строки_______________________________________
Функция len позволяет получить количество символов в строке:

In [1]: line = 'interface Gi0/1'

In [2]: len(line)
Out[2]: 15
__________________________________строки_______________________________________

Методы upper(), lower(), swapcase(), capitalize() выполняют преобразование регистра строки:

In [25]: string1 = 'FastEthernet'

Все большими буквами
In [26]: string1.upper()
Out[26]: 'FASTETHERNET'

Все маленькими буквами
In [27]: string1.lower()
Out[27]: 'fastethernet'

Смена большие на маленькие
In [28]: string1.swapcase()
Out[28]: 'fASTeTHERNET'

Первую букву делает большой
In [29]: string2 = 'tunnel 0'
In [30]: string2.capitalize()
Out[30]: 'Tunnel 0'
__________________________________строки_______________________________________

Метод count() используется для подсчета того, сколько раз символ или подстрока встречаются в строке:

In [33]: string1 = 'Hello, hello, hello, hello'

In [34]: string1.count('hello')
Out[34]: 3

In [35]: string1.count('ello')
Out[35]: 4
__________________________________строки_______________________________________

Методу find() можно передать подстроку или символ, и он покажет, на какой позиции находится первый символ подстроки (для первого совпадения):

In [37]: string1 = 'interface FastEthernet0/1'

In [38]: string1.find('Fast')
Out[38]: 10

In [39]: string1[string1.find('Fast')::]
Out[39]: 'FastEthernet0/1'
__________________________________строки_______________________________________

Проверка на то, начинается или заканчивается ли строка на определенные символы (методы startswith(), endswith()):

In [40]: string1 = 'FastEthernet0/1'

In [41]: string1.startswith('Fast')
Out[41]: True

In [42]: string1.startswith('fast')
Out[42]: False

In [43]: string1.endswith('0/1')
Out[43]: True

In [44]: string1.endswith('0/2')
Out[44]: False

__________________________________строки_______________________________________

Замена последовательности символов в строке на другую последовательность (метод replace()):

In [45]: string1 = 'FastEthernet0/1'

In [46]: string1.replace('Fast', 'Gigabit')
Out[46]: 'GigabitEthernet0/1'

__________________________________строки_______________________________________

Для того, чтобы избавиться от спецсимволов, очень удобно использовать метод strip():

In [47]: string1 = '\n\tinterface FastEthernet0/1\n'

In [48]: print(string1)

    interface FastEthernet0/1


In [49]: string1
Out[49]: '\n\tinterface FastEthernet0/1\n'

In [50]: string1.strip()
Out[50]: 'interface FastEthernet0/1'
 
 
In [51]: ad_metric = '[110/1045]'

In [52]: ad_metric.strip('[]')
Out[52]: '110/1045'

Метод strip() убирает спецсимволы и в начале, и в конце строки. Если необходимо убрать символы только слева или только справа, можно использовать, соответственно, методы lstrip() и rstrip().

__________________________________строки_______________________________________

Из строки делает список
Метод split() разбивает строку на части, используя как разделитель какой-то символ (или символы) и возвращает список строк:

In [53]: string1 = 'switchport trunk allowed vlan 10,20,30,100-200'

In [54]: commands = string1.split()

In [55]: print(commands)
['switchport', 'trunk', 'allowed', 'vlan', '10,20,30,100-200']

__________________________________строки_______________________________________

Форматирование строк с методом format
Вставляет в скабки значение

In [1]: "interface FastEthernet0/{}".format('1')
Out[1]: 'interface FastEthernet0/1'

In [3]: vlan, mac, intf = ['100', 'aabb.cc80.7000', 'Gi0/1']

In [4]: print("{:>15} {:>15} {:>15}".format(vlan, mac, intf))
            100  aabb.cc80.7000           Gi0/1

Выравнивание по левой стороне:

In [5]: print("{:15} {:15} {:15}".format(vlan, mac, intf))
100             aabb.cc80.7000  Gi0/1

______________________________

Указав индексы значений, которые передаются методу format, можно избавиться от дублирования:

In [21]: ip_template = '''
    ...: IP address:
    ...: {0:<8} {1:<8} {2:<8} {3:<8}
    ...: {0:08b} {1:08b} {2:08b} {3:08b}
    ...: '''

In [22]: print(ip_template.format(192, 100, 1, 1))

IP address:
192      100      1        1
11000000 01100100 00000001 00000001

__________________________________строки_______________________________________

In [1]: ip = '10.1.1.1'

In [2]: mask = 24

In [3]: f"IP: {ip}, mask: {mask}"
Out[3]: 'IP: 10.1.1.1, mask: 24'

Аналогичный результат с format можно получить так:
``"IP: {ip}, mask: {mask}".format(ip=ip, mask=mask)``.

Очень важное отличие f-строк от format: f-строки — это выражение, которое выполняется, а не просто строка. То есть, в случае с ipython, как только мы написали выражение и нажали Enter, оно выполнилось и вместо выражений {ip} и {mask} подставились значения переменных.

Поэтому, например, нельзя сначала написать шаблон, а затем определить переменные, которые используются в шаблоне:

__________________________________строки_______________________________________



