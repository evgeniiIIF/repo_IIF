Функция int() позволяет выполнять конвертацию в тип int (из строки в число) только из целого числа???
In [18]: a = '11'
In [19]: int(a)
Out[19]: 11

Если указать, что строку a надо воспринимать как двоичное число, то результат будет таким:
In [20]: int(a, 2)
Out[20]: 3
__________________________________числа_______________________________________

Функция bin позволяет получить двоичное представление числа (обратите внимание, что результат - строка):
In [23]: bin(8)
Out[23]: '0b1000'

In [24]: bin(255)
Out[24]: '0b11111111'
__________________________________числа_______________________________________

Аналогично, функция hex() позволяет получить шестнадцатеричное значение:

In [25]: hex(10)
Out[25]: '0xa'
__________________________________числа_______________________________________

__________________________________строки_______________________________________
Функция len позволяет получить количество символов в строке:

In [1]: line = 'interface Gi0/1'

In [2]: len(line)
Out[2]: 15
__________________________________строки_______________________________________

Методы upper(), lower(), swapcase(), capitalize() выполняют преобразование регистра строки:

In [25]: string1 = 'FastEthernet'

Все большими буквами
In [26]: string1.upper()
Out[26]: 'FASTETHERNET'

Все маленькими буквами
In [27]: string1.lower()
Out[27]: 'fastethernet'

Смена большие на маленькие
In [28]: string1.swapcase()
Out[28]: 'fASTeTHERNET'

Первую букву делает большой
In [29]: string2 = 'tunnel 0'
In [30]: string2.capitalize()
Out[30]: 'Tunnel 0'
__________________________________строки_______________________________________

Метод count() используется для подсчета того, сколько раз символ или подстрока встречаются в строке:

In [33]: string1 = 'Hello, hello, hello, hello'

In [34]: string1.count('hello')
Out[34]: 3

In [35]: string1.count('ello')
Out[35]: 4
__________________________________строки_______________________________________

Методу find() можно передать подстроку или символ, и он покажет, на какой позиции находится первый символ подстроки (для первого совпадения):

In [37]: string1 = 'interface FastEthernet0/1'

In [38]: string1.find('Fast')
Out[38]: 10

In [39]: string1[string1.find('Fast')::]
Out[39]: 'FastEthernet0/1'
__________________________________строки_______________________________________

Проверка на то, начинается или заканчивается ли строка на определенные символы (методы startswith(), endswith()):

In [40]: string1 = 'FastEthernet0/1'

In [41]: string1.startswith('Fast')
Out[41]: True

In [42]: string1.startswith('fast')
Out[42]: False

In [43]: string1.endswith('0/1')
Out[43]: True

In [44]: string1.endswith('0/2')
Out[44]: False

__________________________________строки_______________________________________

Замена последовательности символов в строке на другую последовательность (метод replace()):

In [45]: string1 = 'FastEthernet0/1'

In [46]: string1.replace('Fast', 'Gigabit')
Out[46]: 'GigabitEthernet0/1'

__________________________________строки_______________________________________

Для того, чтобы избавиться от спецсимволов, очень удобно использовать метод strip():

In [47]: string1 = '\n\tinterface FastEthernet0/1\n'

In [48]: print(string1)

    interface FastEthernet0/1


In [49]: string1
Out[49]: '\n\tinterface FastEthernet0/1\n'

In [50]: string1.strip()
Out[50]: 'interface FastEthernet0/1'
 
 
In [51]: ad_metric = '[110/1045]'

In [52]: ad_metric.strip('[]')
Out[52]: '110/1045'

Метод strip() убирает спецсимволы и в начале, и в конце строки. Если необходимо убрать символы только слева или только справа, можно использовать, соответственно, методы lstrip() и rstrip().

__________________________________строки_______________________________________

Из строки делает список
Метод split() разбивает строку на части, используя как разделитель какой-то символ (или символы) и возвращает список строк:

In [53]: string1 = 'switchport trunk allowed vlan 10,20,30,100-200'

In [54]: commands = string1.split()

In [55]: print(commands)
['switchport', 'trunk', 'allowed', 'vlan', '10,20,30,100-200']

__________________________________строки_______________________________________

Форматирование строк с методом format
Вставляет в скабки значение

In [1]: "interface FastEthernet0/{}".format('1')
Out[1]: 'interface FastEthernet0/1'

In [3]: vlan, mac, intf = ['100', 'aabb.cc80.7000', 'Gi0/1']

In [4]: print("{:>15} {:>15} {:>15}".format(vlan, mac, intf))
            100  aabb.cc80.7000           Gi0/1

Выравнивание по левой стороне:

In [5]: print("{:15} {:15} {:15}".format(vlan, mac, intf))
100             aabb.cc80.7000  Gi0/1

______________________________

Указав индексы значений, которые передаются методу format, можно избавиться от дублирования:

In [21]: ip_template = '''
    ...: IP address:
    ...: {0:<8} {1:<8} {2:<8} {3:<8}
    ...: {0:08b} {1:08b} {2:08b} {3:08b}
    ...: '''

In [22]: print(ip_template.format(192, 100, 1, 1))

IP address:
192      100      1        1
11000000 01100100 00000001 00000001

__________________________________строки_______________________________________

In [1]: ip = '10.1.1.1'

In [2]: mask = 24

In [3]: f"IP: {ip}, mask: {mask}"
Out[3]: 'IP: 10.1.1.1, mask: 24'

Аналогичный результат с format можно получить так:
``"IP: {ip}, mask: {mask}".format(ip=ip, mask=mask)``.

Очень важное отличие f-строк от format: f-строки — это выражение, которое выполняется, а не просто строка. То есть, в случае с ipython, как только мы написали выражение и нажали Enter, оно выполнилось и вместо выражений {ip} и {mask} подставились значения переменных.

Поэтому, например, нельзя сначала написать шаблон, а затем определить переменные, которые используются в шаблоне:

__________________________________строки_______________________________________

Перевернуть список наоборот можно и с помощью метода reverse():

In [10]: vlans = ['10', '15', '20', '30', '100-200']

In [11]: vlans.reverse()

In [12]: vlans
Out[12]: ['100-200', '30', '20', '15', '10']

__________________________________списки_______________________________________

Функция len возвращает количество элементов в списке:

In [1]: items = [1, 2, 3]

In [2]: len(items)
Out[2]: 3

__________________________________списки_______________________________________

А функция sorted сортирует элементы списка по возрастанию и возвращает новый список с отсортированными элементами:

In [1]: names = ['John', 'Michael', 'Antony']

In [2]: sorted(names)
Out[2]: ['Antony', 'John', 'Michael']

__________________________________списки_______________________________________

Метод join() собирает список в строку с разделителем, который указан перед join:

In [16]: vlans = ['10', '20', '30']

In [17]: ','.join(vlans)
Out[17]: '10,20,30'

__________________________________списки_______________________________________

Метод append() добавляет в конец списка указанный элемент:

In [18]: vlans = ['10', '20', '30', '100-200']

In [19]: vlans.append('300')

In [20]: vlans
Out[20]: ['10', '20', '30', '100-200', '300']

Метод append меняет список на месте и ничего не возвращает.

__________________________________списки_______________________________________

Если нужно объединить два списка, то можно использовать два способа: метод extend() и операцию сложения.
У этих способов есть важное отличие - extend меняет список, к которому применен метод, а суммирование возвращает новый список, который состоит из двух.

In [21]: vlans = ['10', '20', '30', '100-200']

In [22]: vlans2 = ['300', '400', '500']

In [23]: vlans.extend(vlans2)

In [24]: vlans
Out[24]: ['10', '20', '30', '100-200', '300', '400', '500']

Суммирование списков:

In [27]: vlans = ['10', '20', '30', '100-200']

In [28]: vlans2 = ['300', '400', '500']

In [29]: vlans + vlans2
Out[29]: ['10', '20', '30', '100-200', '300', '400', '500']

__________________________________списки_______________________________________
Удалить из списка
Метод pop() удаляет элемент, который соответствует указанному номеру. Но, что важно, при этом метод возвращает этот элемент:

In [28]: vlans = ['10', '20', '30', '100-200']

In [29]: vlans.pop(-1)
Out[29]: '100-200'

In [30]: vlans
Out[30]: ['10', '20', '30']
_____

Метод remove() удаляет указанный элемент.

remove() не возвращает удаленный элемент:

In [31]: vlans = ['10', '20', '30', '100-200']

In [32]: vlans.remove('20')

In [33]: vlans
Out[33]: ['10', '30', '100-200']

В методе remove надо указывать сам элемент, который надо удалить, а не его номер в списке. Если указать номер элемента, возникнет ошибка:

__________________________________списки_______________________________________

Метод index() используется для того, чтобы проверить, под каким номером в списке хранится элемент:

In [35]: vlans = ['10', '20', '30', '100-200']

In [36]: vlans.index('30')
Out[36]: 2

__________________________________списки_______________________________________

Метод insert() позволяет вставить элемент на определенное место в списке:

In [37]: vlans = ['10', '20', '30', '100-200']

In [38]: vlans.insert(1, '15')

In [39]: vlans
Out[39]: ['10', '15', '20', '30', '100-200']

__________________________________списки_______________________________________

Метод sort сортирует список на месте:

In [40]: vlans = [1, 50, 10, 15]

In [41]: vlans.sort()

In [42]: vlans
Out[42]: [1, 10, 15, 50]

__________________________________словари_______________________________________

Метод clear() позволяет очистить словарь:

In [1]: london = {'name': 'London1', 'location': 'London Str', 'vendor': 'Cisco', 'model': '4451', 'ios': '15.4'}

In [2]: london.clear()

In [3]: london
Out[3]: {}

---------
copy()

Метод copy() позволяет создать полную копию словаря.

Если указать, что один словарь равен другому:

london = {'name': 'London1', 'location': 'London Str', 'vendor': 'Cisco'}

In [11]: london2 = london.copy()

In [12]: id(london)
Out[12]: 25524512

In [13]: id(london2)
Out[13]: 25563296

In [14]: london['vendor'] = 'Juniper'

In [15]: london2['vendor']
Out[15]: 'Cisco'

__________________________________словари_______________________________________

Метод get() запрашивает ключ, и если его нет, вместо ошибки возвращает None.

In [18]: london = {'name': 'London1', 'location': 'London Str', 'vendor': 'Cisco'}

In [19]: print(london.get('ios'))
None

Метод get() позволяет также указывать другое значение вместо None:

In [20]: print(london.get('ios', 'Ooops'))
Ooops

__________________________________словари_______________________________________

Метод setdefault() ищет ключ, и если его нет, вместо ошибки создает ключ со значением None.

In [21]: london = {'name': 'London1', 'location': 'London Str', 'vendor': 'Cisco'}

In [22]: ios = london.setdefault('ios')

In [23]: print(ios)
None

In [24]: london
Out[24]: {'name': 'London1', 'location': 'London Str', 'vendor': 'Cisco', 'ios': None}

Если ключ есть, setdefault возвращает значение, которое ему соответствует:

In [25]: london.setdefault('name')
Out[25]: 'London1'

__________________________________словари_______________________________________

Методы keys(), values(), items():

In [24]: london = {'name': 'London1', 'location': 'London Str', 'vendor': 'Cisco'}

In [25]: london.keys()
Out[25]: dict_keys(['name', 'location', 'vendor'])

In [26]: london.values()
Out[26]: dict_values(['London1', 'London Str', 'Cisco'])

In [27]: london.items()
Out[27]: dict_items([('name', 'London1'), ('location', 'London Str'), ('vendor', 'Cisco')])

Все три метода возвращают специальные объекты view, которые отображают ключи, значения и пары ключ-значение словаря соответственно.

__________________________________словари_______________________________________


del

Удалить ключ и значение:

In [35]: london = {'name': 'London1', 'location': 'London Str', 'vendor': 'Cisco'}

In [36]: del london['name']

In [37]: london
Out[37]: {'location': 'London Str', 'vendor': 'Cisco'}

__________________________________словари_______________________________________

update

Метод update позволяет добавлять в словарь содержимое другого словаря:

In [38]: r1 = {'name': 'London1', 'location': 'London Str'}

In [39]: r1.update({'vendor': 'Cisco', 'ios':'15.2'})

In [40]: r1
Out[40]: {'name': 'London1', 'location': 'London Str', 'vendor': 'Cisco', 'ios': '15.2'
--------------------
Аналогичным образом можно обновить значения:

In [41]: r1.update({'name': 'london-r1', 'ios':'15.4'})

In [42]: r1
Out[42]:
{'name': 'london-r1',
 'location': 'London Str',
 'vendor': 'Cisco',
 'ios': '15.4'}
__________________________________словари_______________________________________
